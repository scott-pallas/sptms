import { NextRequest, NextResponse } from 'next/server'
import { getPayload } from 'payload'
import configPromise from '@payload-config'
import type { Load } from '@/payload-types'

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const payload = await getPayload({ config: configPromise })

    // Fetch the original load
    const originalLoad = await payload.findByID({
      collection: 'loads',
      id,
    }) as Load

    if (!originalLoad) {
      return NextResponse.json({ error: 'Load not found' }, { status: 404 })
    }

    // Parse request body for any overrides
    let overrides: Partial<Load> = {}
    try {
      const body = await request.json()
      overrides = body || {}
    } catch {
      // No body provided, that's fine
    }

    // Fields to exclude from duplication
    const excludeFields = [
      'id',
      'loadNumber', // Will be auto-generated
      'createdAt',
      'updatedAt',
      'statusHistory', // Start fresh
      'rateConSent',
      'rateConSentDate',
      'macropointTracking', // Reset tracking
      'requiredDocuments', // Reset document status
      'documents', // Don't copy attached documents
      'driverInfo', // Clear driver info
    ]

    // Create new load data from original
    const newLoadData: Record<string, unknown> = {}

    for (const [key, value] of Object.entries(originalLoad)) {
      if (!excludeFields.includes(key) && value !== undefined) {
        // Handle relationships - extract ID if it's an object
        if (key === 'customer' || key === 'carrier' || key === 'pickupLocation' || key === 'deliveryLocation') {
          if (typeof value === 'object' && value !== null && 'id' in value) {
            newLoadData[key] = (value as { id: string }).id
          } else {
            newLoadData[key] = value
          }
        } else {
          newLoadData[key] = value
        }
      }
    }

    // Reset status to booked
    newLoadData.status = 'booked'

    // Reset document status
    newLoadData.requiredDocuments = {
      hasBOL: false,
      hasPOD: false,
      hasRateCon: false,
    }

    // Reset rate con status
    newLoadData.rateConSent = false

    // Clear carrier assignment if requested
    if (overrides.carrier === null) {
      delete newLoadData.carrier
      delete newLoadData.carrierRate
    }

    // Apply any overrides from request
    Object.assign(newLoadData, overrides)

    // Create the new load (load number will be auto-generated by hook)
    const newLoad = await payload.create({
      collection: 'loads',
      data: newLoadData as any,
    })

    return NextResponse.json({
      success: true,
      message: 'Load duplicated successfully',
      load: newLoad,
    })
  } catch (error) {
    console.error('Error duplicating load:', error)
    return NextResponse.json(
      { error: 'Failed to duplicate load' },
      { status: 500 }
    )
  }
}
